package uk.ac.ucl.comp2010.bestgroup;

import java_cup.runtime.*;
import uk.ac.ucl.comp2010.bestgroup.AST.*;
import java.util.LinkedList;

terminal SEMICOLON, COMMA, DOT, COLON;
terminal LEFTBRACE, RIGHTBRACE;
terminal LEFTBRACKET, RIGHTBRACKET;
terminal LEFTTBRACKET, RIGHTTBRACKET;
terminal LEFTPAREN, RIGHTPAREN;

terminal BOOL, INT, FLOAT, STRING, LIST, CHAR, TUPLE, VOID;
terminal String ID;
terminal String STRINGLITERAL;
terminal boolean BOOLLITERAL;
terminal int INTLITERAL;
terminal float FLOATLITERAL;
terminal char CHARLITERAL;

terminal FDEF, TDEF;

terminal ASSIGN;
terminal NOT, OR, AND;
terminal PLUS, MINUS, MULTIPLY, DIVIDE, POWER;
terminal IN, LENGTH, CONCAT;
terminal LESSTHAN, LESSTHANEQUAL, GREATERTHAN, GREATERTHANEQUAL, EQUAL, NOTEQUAL;

terminal IF, ELSE, REPEAT, UNTIL, RETURN, DO, WHILE;

non terminal String type;
non terminal AccessorNode accessor;
non terminal ExprNode expression, term, factor, exponent, final;
non terminal FuncCallExprNode function_call;
non terminal SequenceNode sequence;
non terminal LinkedList<ExprNode> list, tuple;
non terminal LinkedList<ExprNode> expression_clist, expression_clist2;
non terminal VarDeclNode var_decl;
non terminal LinkedList<ExprNode> var_init;
non terminal VarTypeNode var_type;

non terminal String function_type;
non terminal FuncDeclNode function_decl;
non terminal LinkedList<VarTypeNode> parameter_clist, parameter_clist2;

non terminal LinkedList<DeclNode> global_decl_list, local_decl_list;
non terminal DeclNode global_decl;
non terminal DatatypeDeclNode datatype_decl;

non terminal BlockNode block;
non terminal LinkedList<StatementNode> statement_list;
non terminal StatementNode statement;
non terminal StatementNode if, ifelse, repeatuntil, while, assignment, return;
non terminal ProgramNode program;

precedence right POWER;
precedence left DIVIDE, MULTIPLY;
precedence left PLUS, MINUS;

precedence nonassoc NOT;
precedence left OR, AND;
precedence right IN;
precedence nonassoc LESSTHAN, LESSTHANEQUAL, GREATERTHAN, GREATERTHANEQUAL, EQUAL, NOTEQUAL;

start with program;

type ::=
BOOL {: RESULT = "bool"; :}
| INT {: RESULT = "int"; :}
| FLOAT {: RESULT = "float"; :}
| STRING {: RESULT = "string"; :}
| CHAR {: RESULT = "char"; :}
| LIST {: RESULT = "list"; :}
| TUPLE {: RESULT = "tuple"; :}
| ID:id {: RESULT = id; :}
;

program ::= 
global_decl_list:decl_list block:block	{: RESULT = new ProgramNode(decl_list, block); :}
| block:block 							{: RESULT = new ProgramNode(block); :}
;

global_decl_list ::= 
global_decl_list:decl_list global_decl:decl {: RESULT = decl_list; RESULT.addLast(decl); :} 
| global_decl:decl 							{: RESULT = new LinkedList<DeclNode>(); RESULT.addFirst(decl); :}
;

global_decl ::= 
datatype_decl:decl	 {: RESULT = decl; :}
| var_decl:decl		 {: RESULT = decl; :}
| function_decl:decl {: RESULT = decl; :}
;

function_decl ::= 
FDEF ID:id LEFTPAREN parameter_clist:param_list RIGHTPAREN COLON function_type:type block:body {:RESULT = new FuncDeclNode(id, param_list, type, body); :}
;

var_type ::= 
ID:id COLON type:type {: RESULT = new VarTypeNode(id, type); :}
; 

var_decl ::= 
var_type:var_type var_init:var_init SEMICOLON {: RESULT = new VarDeclNode(var_type, var_init); :};

var_init ::=
ASSIGN expression_clist:expr_list {: RESULT = expr_list; :} 
|								  {: :}
;

datatype_decl ::=
TDEF ID:id COLON parameter_clist:param_list SEMICOLON {: RESULT = new DatatypeDeclNode(id, param_list); :}
;

function_type ::= 
VOID 		{: RESULT = "void"; :}
| type:type	{: RESULT = type; :}
;

//two-productions are needed to avoid ambiguity
parameter_clist ::= 
var_type:param parameter_clist2:param_list	{: RESULT = param_list; RESULT.addFirst(param); :} 
|											{: RESULT = new LinkedList<VarTypeNode>(); :}
;

parameter_clist2 ::= 
COMMA var_type:param parameter_clist2:param_list 	{: RESULT = param_list; RESULT.addFirst(param); :}
|													{: RESULT = new LinkedList<VarTypeNode>(); :}
;

block ::= 
LEFTBRACE local_decl_list:decl_list statement_list:statement_list RIGHTBRACE 	{: RESULT = new BlockNode(decl_list, statement_list); :}
| LEFTBRACE statement_list:statement_list RIGHTBRACE							{: RESULT = new BlockNode(statement_list); :}
;

// Local declaration only allows variable declarations
local_decl_list ::= 
local_decl_list:decl_list var_decl:decl		{: RESULT = decl_list; RESULT.addLast(decl); :}
| var_decl:decl								{: RESULT = new LinkedList<DeclNode>(); RESULT.addFirst(decl); :}
;

statement_list ::= 
statement:statement statement_list:statement_list 	{: RESULT = statement_list; RESULT.addFirst(statement); :}
|													{: RESULT = new LinkedList<StatementNode>(); :}
;

statement ::= 
assignment:stmt					{: RESULT = stmt; :}
| function_call:call SEMICOLON	{: RESULT = new FuncCallStmtNode(call); :}
| ifelse:stmt					{: RESULT = stmt; :} 
| if:stmt						{: RESULT = stmt; :}
| while:stmt					{: RESULT = stmt; :}				
| repeatuntil:stmt				{: RESULT = stmt; :}
| return:stmt					{: RESULT = stmt; :}
;

ifelse ::= 
IF LEFTPAREN expression:condition RIGHTPAREN block:true_block ELSE block:false_block {: RESULT = new IfNode(condition, true_block, false_block); :}
;

if ::= 
IF LEFTPAREN expression:condition RIGHTPAREN block:true_block {: RESULT = new IfNode(condition, true_block); :}
;

while ::=
WHILE LEFTPAREN expression:condition RIGHTPAREN DO block:loop {: RESULT = new WhileNode(condition, loop); :}
;

repeatuntil ::= 
REPEAT block:loop UNTIL LEFTPAREN expression:condition RIGHTPAREN SEMICOLON {: RESULT = new RepeatNode(loop, condition); :} 
;

function_call ::=
ID:id LEFTPAREN expression_clist:expr_list RIGHTPAREN {: RESULT = new FuncCallExprNode(id, expr_list); :} 
;

return ::= 
RETURN expression:expr SEMICOLON	{: RESULT = new ReturnNode(expr); :}
| RETURN SEMICOLON					{: RESULT = new ReturnNode(); :}
;

assignment ::= 
accessor:accessor ASSIGN expression:expr SEMICOLON	{: RESULT = new AssignmentNode(accessor, expr); :}
;

sequence ::=
STRINGLITERAL:str	{: RESULT = new StringNode(str);  :}
| tuple:seq			{: RESULT = new SequenceNode(seq); :}
| list:seq			{: RESULT = new SequenceNode(seq); :}
;

accessor ::= 
ID:id						{: RESULT = new AccessorNode(id); :}
| accessor:parent DOT ID:id	{: RESULT = new AccessorNode(parent, id); :} 
;

tuple ::=
LEFTTBRACKET expression_clist:expr_list RIGHTTBRACKET {: RESULT = expr_list; :}
;

list ::= 
LEFTBRACKET expression_clist:expr_list RIGHTBRACKET {: RESULT = expr_list; :}
;

expression_clist ::= 
expression:expr expression_clist2:expr_list {: RESULT = expr_list; RESULT.addFirst(expr); :}
|											{: RESULT = new LinkedList<ExprNode>(); :}
;

expression_clist2 ::= 
COMMA expression:expr expression_clist2:expr_list 	{: RESULT = expr_list; RESULT.addFirst(expr); :}
|													{: RESULT = new LinkedList<ExprNode>(); :}
;

expression ::=
term:e							{: RESULT = e; :}
| NOT expression:e				{: RESULT = new NotNode(e); :}
| expression:e1 PLUS term:e2	{: RESULT = new NumericOperationNode(NumericOperationNode.PLUS, e1, e2); :}
| expression:e1 MINUS term:e2	{: RESULT = new NumericOperationNode(NumericOperationNode.MINUS, e1, e2); :}
| expression:e1 OR term:e2		{: RESULT = new BooleanOperationNode(BooleanOperationNode.OR, e1, e2); :}
| expression:e1 IN term:e2		{: RESULT = new InNode(e1, e2); :}
| expression:e1 LESSTHAN term:e2{: RESULT = new ComparisonNode(ComparisonNode.LESSTHAN, e1, e2); :}
| expression:e1 LESSTHANEQUAL term:e2	{: RESULT = new ComparisonNode(ComparisonNode.LESSTHANEQUAL, e1, e2); :}
| expression:e1 GREATERTHAN term:e2		{: RESULT = new ComparisonNode(ComparisonNode.GREATERTHAN, e1, e2); :}
| expression:e1 GREATERTHANEQUAL term:e2{: RESULT = new ComparisonNode(ComparisonNode.GREATERTHANEQUAL, e1, e2); :}
| expression:e1 EQUAL term:e2			{: RESULT = new EqualsNode(EqualsNode.EQUAL, e1, e2); :}
| expression:e1 NOTEQUAL term:e2		{: RESULT = new EqualsNode(EqualsNode.NOTEQUAL, e1, e2); :}
| expression:e1 CONCAT term:e2			{: RESULT = new ConcatNode(e1, e2); :}
| expression:e1 LEFTBRACKET expression:e2 COLON expression:e3 RIGHTBRACKET {: RESULT = new IndexRangeNode(e1, e2, e3); :}
| expression:e1 LEFTBRACKET expression:e2 COLON RIGHTBRACKET			   {: RESULT = new IndexRangeNode(e1, e2, null); :}
| expression:e1 LEFTBRACKET COLON expression:e2 RIGHTBRACKET			   {: RESULT = new IndexRangeNode(e1, null, e2); :}
| expression:e1 LEFTBRACKET expression:e2 RIGHTBRACKET					   {: RESULT = new IndexNode(e1, e2); :}
;

term ::=
factor:e					{: RESULT = e; :}
| term:e1 MULTIPLY factor:e2 {: RESULT = new NumericOperationNode(NumericOperationNode.MULTIPLY, e1, e2); :}
| term:e1 DIVIDE factor:e2	{: RESULT = new NumericOperationNode(NumericOperationNode.DIVIDE, e1, e2); :}
| term:e1 POWER factor:e2	{: RESULT = new NumericOperationNode(NumericOperationNode.POWER, e1, e2); :}
| term:e1 AND factor:e2		{: RESULT = new BooleanOperationNode(BooleanOperationNode.AND, e1, e2); :}
;

factor ::=
exponent:e1 POWER factor:e2 {: RESULT = new NumericOperationNode(NumericOperationNode.POWER, e1, e2); :}
| exponent:e				{: RESULT = e; :}
;

exponent ::=
MINUS exponent:e			{: RESULT = new NegativeNode(e); :}
| final:e					{: RESULT = e; :}
;

final ::=
accessor:e							{: RESULT = e; :}
| LEFTPAREN expression:e RIGHTPAREN	{: RESULT = e; :}
| INTLITERAL:val					{: RESULT = new IntNode(val); :}												
| FLOATLITERAL:val					{: RESULT = new FloatNode(val); :}
| BOOLLITERAL:val					{: RESULT = new BoolNode(val); :}
| CHARLITERAL:val					{: RESULT = new CharNode(val); :}
| function_call:e					{: RESULT = e; :}
| LENGTH LEFTPAREN expression:e RIGHTPAREN	{: RESULT = new LengthNode(e); :}
| sequence:e 						{: RESULT = e; :} 
;
